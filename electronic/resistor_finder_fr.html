<!DOCTYPE html>
<html lang="fr">
	<head>
	  <meta name="Resistance finder" content="DIY heaven resistance finder"/>
	  <meta charset="utf-8" />
	  <title>Resistance finder</title>
	  <style>
	    body{
	      
	    }
	    #corps{
		display:inline-block;
		text-align:center;
		width:100%;
	    }
	    .cadre{
		border: 3px solid black;
		background-color:#E6E6FA;
		display:inline-block;
		width:46em;
		border-radius:0.1em;
		box-shadow: 10px 10px 5px #888888;
	    }
	    header{
	      text-align:center;
	      background-color:rgba(173,173,173,0.25);
	    }
	    .cadre h2{
	      border: 1.5px solid black;
	    }
	    .stock{
		width: 90%;
	    }
	    
	    .formule{
		width: 40%;
	    }
	    
	    .valeur{
		width: 10%;
	    }
	    footer {
		position:fixed;
		bottom:0;
		font-size: small;
		color: #7F7F7F;
		background-color:black;
		width:100%;
		text-align:center;
	    }
	    #legende {
		font-size: small;
	    }
	    #ecart,#resistance,#nbresistances{
	      position:absolute;
	      left:60%;
	      width:10em;
	    }
	    .block_stock {
	      position:relative;
	      left:10%;
	      text-align:left;
	    }
	    #block_form1 {
	      position:relative;
	      left:10%;
	      text-align:left;
	    }
	    #block_form2 {
	      position:relative;
	      left:10%;
	      text-align:left;
	      color:#2D2D2D;
	    }
	    #block_form1 button{
	      position:absolute;
	      left:60%;
	    }
	    button{
	      border: 1.5px solid black;
	      background-color:white;
	    }
	    button:hover{
	      background-color:#40FF40;
	    }
	  </style>
	 </head>
    <body>
       <header id="titre">
	   <h1>Explorateur de stock électronique</h1>
       </header>
       <section id='corps'>
	<article class="cadre" id="calcul_resistance">
	    <header><h2>Recherche de combinaisons de résistances</h2></header>
	    <div class='block_stock'>
	      <label for="mon_stock">Stock de resistances <small>(en ohm, séparé par des espaces)</small>:<br></label>
	    </div>
	    <input type="string" value="21k 21k 1k 10k 20k 7k 9k" class="stock" name="mon_stock" id="mon_stock" title="Aide : les notations k=*1000 m=*1000000 sont authorisées"></input>
	    
	    <br>
	    <br>
	    <div id='block_form1'>
	      <label for="resistance">Résistance souhaitée <small>(en ohm)</small></label><input type="number" value="10500" name="resistance" id="resistance"></input>
	      <br>
	      <label for="ecart">Écart maximum <small>(en %)</small></label><input type="float" value="0.2" name="ecart" id="ecart"></input>
	      <br>
	      <label for="nbresistances">Nombre maximum de resistances utilisées </label><input type="number" value="5" min=1 max=10 name="nbresistances" id="nbresistances"></input>
	      <br>
	      <button OnClick="calcul_combinaisons()">Calculer</button>
	      <br>
	    </div>
	    <div id='block_form2'>
	      <label for="grp_resistance1">Solution 1 : </label><input class="formule" type="text" name="grp_resistance1" id="grp_resistance1" disabled></input>
	      <label for="grp_resistance_val1"> vaut </label><input class="valeur" type="text" name="grp_resistance_val1" id="grp_resistance_val1" disabled></input>
	      <button OnClick="prendre_grp1()">Prendre</button>
	      <br>
	      <label for="grp_resistance2">Solution 2 : </label><input class="formule" type="text" name="grp_resistance2" id="grp_resistance2" disabled></input>
	      <label for="grp_resistance_val2"> vaut </label><input class="valeur" type="text" name="grp_resistance_val2" id="grp_resistance_val2" disabled></input>
	      <button OnClick="prendre_grp2()">Prendre</button>
	      
	      <br>
	      <label for="grp_resistance3">Solution 3 : </label><input class="formule" type="text" name="grp_resistance3" id="grp_resistance3" disabled></input>
	      <label for="grp_resistance_val3"> vaut </label><input class="valeur" type="text" name="grp_resistance_val3" id="grp_resistance_val3" disabled></input>
	      <button OnClick="prendre_grp3()">Prendre</button>
	      <br>
	    </div>
	    <div class='block_stock'>
	      <label for="mon_stock_pris">Resistances mises de coté :<br></label>
	    </div>
	    <input type="string" value="" class="stock" name="mon_stock_pris" id="mon_stock_pris" title="Copier-Coller pour remettre les résistances dans le stock"></input>
	    <br>
	    
	    <p id="legende">Légende :  ( R1 <strong>+</strong> R2 ) &rarr; résistances en série; ( R1 <strong>//</strong> R2 ) &rarr; résistances en parallèle.  </p>
	        
      </article>
      </section>
      <footer>
            DIY. 2015 Copyleft : Sébastien Gillot.<br>
	    Tests navigateurs : Chromium Ok; Mozilla Ok.
      </footer>
      <!--Javascript-->
    <script>
	<!-- Important note : this program use the concept of stock, 2 type of stock are used:
	<!-- 	- simple stock represents the reserves
	<!-- 	- computed stock represents all combinations possibles
	<!--
	<!-- Moreover the stock contains the value of the componants represented by the different formula (or set of componants) avaible :
	<!--     { "formula1" : {"componant1":qte,"componant2":qte}, "formula2" : {"componant3":qte,"componant2":qte} }
	<!-- So we have set of value associated to a set of set of componants.
	<!--	
	<!-- Here the structure of the stock concept.
	<!--   simple stock = { value1 : { "componant1" : {"componant1":qte}},
	<!--             	value2 : { "componant2" : {"componant2":qte}},... }
	<!--   computed stock = { value1 : { "formula1" : {"componant1":qte,"componant2":qte}},
	<!--             value2 : { "formula2" : {"componant1":qte,... }},"formula3" : {"componant1":qte,... }},... }
	-->
	
	<!--stock related functions-->
	function formula_copy(a){
	  var res={'_nb_':0};
	  var v_k;
	  for (v_k in a){
	    if (v_k!='_nb_'){
	      res[v_k]=a[v_k];
	      res['_nb_']=res['_nb_']+a[v_k];
	    }
	  }
	  return res;
	}

	function formula_set_copy(a){// input : 1 set of formulas 
	  var res={};
	  var v_k;
	  for (v_k in a){
	    res[v_k]=formula_copy(a[v_k]);
	  }
	  return res;
	}

	function formula_union(a,b){// input : 2 formulas
	  var res=formula_copy(a);
	  var v_k;
	  for (v_k in b){
	    if (v_k!='_nb_'){
	      if (v_k in res){
		  res[v_k]=res[v_k]+b[v_k];
	      } else {
		  res[v_k]=b[v_k];
	      }
	      res['_nb_']=res['_nb_']+b[v_k];
	    }
	  }
	  return res;
	}

	function formula_equal(a,b){// input : 2 formulas
	  if (a['_nb_']!=b['_nb_']){
	    return false;
	  }
	  var v_k;
	  for (v_k in a){
	    if ((!v_k in b) || (a[v_k]!=b[v_k])){
	      return false;
	    }
	  }
	  return true;
	}
	
	function exist_equal_formula(a,b){//input : b is a set of formulas,  "a" is a formula {"componant1":qte,"componant2":qte}
	  for (var f in b){
	      if (formula_equal(a,b[f])){
		return true;
	      }
	  }
	  return false;
	}
	
	function test_a_in_stock_b(a,b){//input : "b" is a stock, "a" is a formula {"componant1":qte,"componant2":qte}
	  var v;
	  for (var k in a){
	    v=parseInt(format_input(k));
	    if ((k!='_nb_') && ((!(v in b)) || (a[k] > b[v][k][k]))) {
	      return false;
	    } 
	  }
	  return true
	}
	function need_better_solution(a,max_qte){// input : { "formula1" : {"componant1":qte,"componant2":qte,'_nb_':x}, "formula2" : ...}
	  var i=0;
	  for (var k in a){
	      if ( a[k]['_nb_'] < (max_qte/2) + 1 ) {//minimum number of components wished is under half of the max quantity
		i++;
	      }
	      i++;
	      if (i==3){
		return false;
	      }
	  }
	  return true;
	}
	<!-- functions to prepare all possible results of combinations -->
	function populate_combine_stock(t_stock,orig_stock,func_combi,symb_combi,max_qte){
	    //~ console.log(t_stock,orig_stock,func_combi,symb_combi,max_qte);
	    var v;
	    var res={};
	    var formula;
	    var formula_stock={};
	    var insert_new_formula=false;
	    for (var k in t_stock) {
	      res[k]=formula_set_copy(t_stock[k]);
	    }
	    for (var h in t_stock) {
	      for (var k in t_stock[h]) {
		for (var i in t_stock) {
		  for (var j in t_stock[i]){
		    v=func_combi(h,i);
		    if(!(v in res)){
		      res[v]={};
		      insert_new_formula=true;
		    } else {
		      if(need_better_solution(res[v],max_qte)){
			insert_new_formula=true;
		      }
		    }
		    if (insert_new_formula) {
		      formula_stock=formula_union(t_stock[h][k],t_stock[i][j]);
		      if ( (formula_stock['_nb_']<=max_qte) &&
			test_a_in_stock_b(formula_stock,orig_stock) ){
			    formula='('+k+' '+symb_combi+' '+j+')';
			    if (!exist_equal_formula(formula_stock,res[v])){
			      res[v][formula]=formula_stock;
			    }
		      }
		      insert_new_formula=false;
		    }
		  }
		}
	      }
	    }
	    return res;
	}
	<!-- functions to find bests results of combinations -->
	function search_group(v_resistance,v_ecart,stock){
	  var res=[];
	  var i=0;
	  var diff;
	  for (var k in stock) {
	      //~ console.log(k+":"+stock[k][0]);
	      var diff=Math.abs(k - v_resistance );
	      if ( diff <= v_ecart ){
		for (var l in stock[k]){
		  res[i]=[Math.round(k),l,diff];
		  i++;
		}
	      }
	  }
	  res.sort(function(a, b){return a[2]-b[2]})
	  return res;
	}
	<!-- functions for computing combinations -->
	function resistances_en_serie(a,b){
	  return parseInt(a)+parseInt(b);
	}
	function resistances_en_parallele(a,b){
	  var v_a=parseInt(a);
	  var v_b=parseInt(b);
	  if (v_a==v_b){
	    return v_a/2;
	  } else {
	    return ((v_a*v_b)/(v_a+v_b));
	  }
	}
	<!-- functions for gui -->
	function format_input(r_val){
	  return r_val.replace(/k/gi,"000").replace(/m/gi,"000000");
	}
	
	function prendre(formule){
	  var grp_parse_tab=formule.replace(/(\(|\)|\+|\/\/)+/g," ").replace(/(\s)+/g," ").replace(/(^\s|\s$)/g,"").split(" ");
	  var i;
	  var new_stock=mon_stock.value.replace(/(^|$)/g," ");
	  var pos;
	  for (i=0;i<grp_parse_tab.length;i++){
	    pos=new_stock.search(new RegExp("( )"+grp_parse_tab[i]+"( )",''));
	    //~ console.log(i,grp_parse_tab[i],pos,new_stock.substr(0,pos+1),new_stock.substr(pos+grp_parse_tab[i].length+2));
	    if (pos<0){//check if stock still avaible
	      return false;
	    }
	    new_stock=new_stock.substr(0,pos+1)+new_stock.substr(pos+grp_parse_tab[i].length+2);
	  }
	  mon_stock.value=new_stock.replace(/(^\s|\s$)/g,"");
	  
	  return true;
	}
	<!-- functions in gui -->
	function calcul_combinaisons(){
	  // stocks representation
	  var stock={'_nb_':0};//all components avaible with their quantity
	  var init_set={};//representation all components avaible without their quantity
	  //values to iterate
	  var i;
	  var v_nb;
	  var v_k;
	  var k;
	  // reinitialization of the output
	  mon_stock.value=mon_stock.value.replace(/(\(|\)|\+|\/\/)+/g," ").replace(/(\s)+/g," ").replace(/(^\s|\s$)/g,"");
	  grp_resistance1.value="";
	  grp_resistance_val1.value="";
	  grp_resistance2.value="";
	  grp_resistance_val2.value="";
	  grp_resistance3.value="";
	  grp_resistance_val3.value="";
	  // build stocks
	  var stock_parse_tab=mon_stock.value.split(" ");
	  for (i=0; i <stock_parse_tab.length; i++){
	      //~ console.log(stock_parse_tab[i]);
	      k=stock_parse_tab[i];
	      v_k=parseInt(format_input(k));
	      if (v_k in stock){
		v_nb=stock[v_k][k][k]+1;
	      } else {
		v_nb=1;
	      }
	      init_set[v_k]={};
	      init_set[v_k][k]={};
	      init_set[v_k][k]['_nb_']=1;
	      init_set[v_k][k][k]=1;
	      
	      stock[v_k]={};
	      stock[v_k][k]={};
	      stock[v_k][k]['_nb_']=v_nb;
	      stock[v_k][k][k]=v_nb;
	  }

	  //~ console.log(stock);
	  // build combinations
	  var max_qte=parseInt(nbresistances.value);
	  var comb_serial_set=populate_combine_stock(init_set,stock,resistances_en_serie,'+',max_qte);
	  var comb_parallel_set=populate_combine_stock(comb_serial_set,stock,resistances_en_parallele,'//',max_qte);
	  //~ console.log(comb_parallel_set);
	  var comb_final_set=populate_combine_stock(comb_parallel_set,stock,resistances_en_serie,'+',max_qte);
	  //~ console.log(comb_final_set);
	  // search the nearests
	  var v_resistance=parseInt(resistance.value);
	  var v_solution=search_group(v_resistance,
				      ((parseFloat(ecart.value)*v_resistance)/100),
				      comb_final_set);

	  // displaying results
	  if (v_solution.length>0){
	    grp_resistance1.value=v_solution[0][1];
	    grp_resistance_val1.value=v_solution[0][0];
	    if (v_solution.length>1){
	      grp_resistance2.value=v_solution[1][1];
	      grp_resistance_val2.value=v_solution[1][0];
	      if (v_solution.length>2){
		grp_resistance3.value=v_solution[2][1];
		grp_resistance_val3.value=v_solution[2][0];
	      }
	    }
	  }
	}
	function prendre_grp1(){
	  if(prendre(grp_resistance1.value)){
	    mon_stock_pris.value=mon_stock_pris.value+' '+grp_resistance1.value;
	  }
	  grp_resistance1.value="";
	  grp_resistance_val1.value="";
	}
	function prendre_grp2(){
	  if(prendre(grp_resistance2.value)){
	    mon_stock_pris.value=mon_stock_pris.value+' '+grp_resistance2.value;
	  }
	  grp_resistance2.value="";
	  grp_resistance_val2.value="";
	}
	function prendre_grp3(){
	  if(prendre(grp_resistance3.value)){
	    mon_stock_pris.value=mon_stock_pris.value+' '+grp_resistance3.value;
	  }
	  grp_resistance3.value="";
	  grp_resistance_val3.value="";
	}
    </script>
<!---->
    </body>
</html>
